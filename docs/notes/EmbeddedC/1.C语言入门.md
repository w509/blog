---
title: C语言入门
createTime: 2025/08/29 22:01:54
---

## 一、C语言基础语法

### 1.1 程序结构

一个完整的C程序包含以下部分：

```c
// 预处理指令
#include <stdio.h>
#include <stdlib.h>

// 函数声明
int add(int a, int b);

// 主函数
int main() {
    // 变量声明
    int result;
    
    // 函数调用
    result = add(5, 3);
    
    // 输出结果
    printf("Result: %d\n", result);
    
    return 0;
}

// 函数定义
int add(int a, int b) {
    return a + b;
}
```

#### 程序结构说明：
- **预处理指令**：以#开头，如`#include`、`#define`
- **函数声明**：告诉编译器函数的存在（可选，如果函数定义在使用前）
- **主函数main()**：程序的入口点，必须存在
- **函数定义**：实现具体的功能

### 1.2 注释

C语言支持两种注释方式：

```c
// 单行注释：从//开始到行尾

/*
   多行注释：
   可以跨越多行
   用于详细说明
*/

/* 也可以在一行内 */
int x = 10; /* 行尾注释 */
```

### 1.3 变量与数据类型

#### 1.3.1 基本数据类型

C语言提供了几种基本数据类型：

| 类型 | 大小（字节） | 范围 | 格式符 |
|------|-------------|------|---------|
| `char` | 1 | -128 到 127 | `%c` |
| `unsigned char` | 1 | 0 到 255 | `%c` |
| `int` | 4 | -2,147,483,648 到 2,147,483,647 | `%d` |
| `unsigned int` | 4 | 0 到 4,294,967,295 | `%u` |
| `short` | 2 | -32,768 到 32,767 | `%hd` |
| `long` | 8 | 很大的范围 | `%ld` |
| `float` | 4 | 6位精度 | `%f` |
| `double` | 8 | 15位精度 | `%lf` |

#### 1.3.2 变量声明和初始化

```c
#include <stdio.h>

int main() {
    // 基本变量声明
    int age;               // 声明整型变量
    float height;          // 声明浮点型变量
    char grade;            // 声明字符型变量
    
    // 变量初始化
    int count = 10;        // 声明并初始化
    float pi = 3.14159f;   // f后缀表示float类型
    char letter = 'A';     // 字符用单引号
    
    // 多个同类型变量声明
    int x, y, z;
    int a = 1, b = 2, c = 3;
    
    // 赋值
    age = 25;
    height = 175.5;
    grade = 'A';
    
    // 输出变量值
    printf("Age: %d\n", age);
    printf("Height: %.1f\n", height);
    printf("Grade: %c\n", grade);
    
    return 0;
}
```

#### 1.3.3 常量

```c
#include <stdio.h>

// 宏定义常量
#define PI 3.14159
#define MAX_SIZE 100

int main() {
    // const关键字定义常量
    const int MAX_STUDENTS = 50;
    const float GRAVITY = 9.8f;
    
    // 使用常量
    printf("圆周率: %f\n", PI);
    printf("最大容量: %d\n", MAX_SIZE);
    printf("最大学生数: %d\n", MAX_STUDENTS);
    
    return 0;
}
```

#### 1.3.4 存储类说明符

C语言提供了几种存储类说明符，用于控制变量的存储位置、生命周期和可见性：

##### **static关键字**

**1. 静态局部变量**

```c
#include <stdio.h>

void count_calls() {
    static int count = 0;  // 静态局部变量，只初始化一次
    count++;
    printf("函数被调用了 %d 次\n", count);
}

int main() {
    count_calls();  // 输出: 函数被调用了 1 次
    count_calls();  // 输出: 函数被调用了 2 次
    count_calls();  // 输出: 函数被调用了 3 次
    return 0;
}
```

**特点：**
- 只在第一次调用时初始化
- 在函数调用结束后保持其值
- 只在声明它的函数内可见

**2. 静态全局变量**

```c
// file1.c
static int global_count = 0;  // 只在当前文件可见

static void internal_function() {  // 只在当前文件可见
    global_count++;
    printf("内部计数: %d\n", global_count);
}

void public_function() {
    internal_function();
}
```

**特点：**
- 限制变量/函数的作用域在当前文件内
- 避免全局命名冲突
- 提供封装性

##### **extern关键字**

用于声明外部变量或函数，表示该变量或函数在其他文件中定义：

```c
// global.c - 定义全局变量
int shared_counter = 100;
char shared_buffer[256];

// main.c - 使用外部变量
#include <stdio.h>

extern int shared_counter;     // 声明外部变量
extern char shared_buffer[];   // 声明外部数组

int main() {
    printf("共享计数器: %d\n", shared_counter);
    shared_counter += 10;
    printf("修改后: %d\n", shared_counter);
    return 0;
}
```

##### **register关键字**

建议编译器将变量存储在寄存器中以提高访问速度：

```c
#include <stdio.h>

int main() {
    register int i;  // 建议存储在寄存器中
    
    // 适用于频繁访问的循环变量
    for (i = 0; i < 1000000; i++) {
        // 大量计算
    }
    
    return 0;
}
```

**注意：**
- 现代编译器通常会自动优化，register关键字作用有限
- 不能对register变量取地址（&操作符）

##### **auto关键字**

默认的存储类，通常省略不写：

```c
int main() {
    auto int x = 10;  // 等价于 int x = 10;
    int y = 20;       // 默认就是auto
    return 0;
}
```

##### **volatile关键字**

告诉编译器该变量可能被程序外部修改，不要对其进行优化：

```c
#include <stdio.h>

// 嵌入式系统中的硬件寄存器
volatile unsigned int *gpio_register = (unsigned int*)0x40020000;

int main() {
    // 编译器不会优化对volatile变量的访问
    *gpio_register = 0xFF;  // 设置GPIO输出
    
    volatile int flag = 0;
    while (flag == 0) {
        // 等待外部中断修改flag
        // 编译器不会优化掉这个循环
    }
    
    return 0;
}
```

**使用场景：**
- 硬件寄存器访问
- 中断服务程序中修改的变量
- 多线程共享变量

##### **const关键字**

定义只读变量，防止意外修改：

```c
#include <stdio.h>

int main() {
    const int max_size = 100;        // 只读变量
    const char *message = "Hello";   // 指向常量的指针
    char * const ptr = &message;     // 常量指针
    const char * const fixed = "Hi"; // 指向常量的常量指针
    
    // max_size = 200;  // 错误：不能修改const变量
    
    printf("最大大小: %d\n", max_size);
    printf("消息: %s\n", message);
    
    return 0;
}
```

**指针与const的组合：**
```c
int value = 42;
int another = 100;

const int *ptr1 = &value;       // 指向常量的指针：不能通过ptr1修改value
int * const ptr2 = &value;      // 常量指针：ptr2不能指向其他地址
const int * const ptr3 = &value; // 常量指针指向常量

*ptr1 = 50;    // 错误：不能修改指向的值
ptr1 = &another; // 正确：可以改变指针指向

*ptr2 = 50;    // 正确：可以修改指向的值
ptr2 = &another; // 错误：不能改变指针指向

*ptr3 = 50;    // 错误：不能修改指向的值
ptr3 = &another; // 错误：不能改变指针指向
```

### 1.4 运算符

#### 1.4.1 算术运算符

| 运算符 | 描述 | 示例 |
|--------|------|------|
| `+` | 加法 | `a + b` |
| `-` | 减法 | `a - b` |
| `*` | 乘法 | `a * b` |
| `/` | 除法 | `a / b` |
| `%` | 取模（余数） | `a % b` |
| `++` | 自增 | `++a` 或 `a++` |
| `--` | 自减 | `--a` 或 `a--` |

```c
#include <stdio.h>

int main() {
    int a = 10, b = 3;
    
    printf("a = %d, b = %d\n", a, b);
    printf("a + b = %d\n", a + b);  // 13
    printf("a - b = %d\n", a - b);  // 7
    printf("a * b = %d\n", a * b);  // 30
    printf("a / b = %d\n", a / b);  // 3 (整数除法)
    printf("a %% b = %d\n", a % b); // 1 (余数)
    
    // 自增自减
    printf("a++ = %d\n", a++);      // 先使用再自增：10
    printf("a = %d\n", a);          // 11
    printf("++b = %d\n", ++b);      // 先自增再使用：4
    
    return 0;
}
```

#### 1.4.2 关系运算符

| 运算符 | 描述 | 示例 |
|--------|------|------|
| `==` | 等于 | `a == b` |
| `!=` | 不等于 | `a != b` |
| `>` | 大于 | `a > b` |
| `<` | 小于 | `a < b` |
| `>=` | 大于等于 | `a >= b` |
| `<=` | 小于等于 | `a <= b` |



#### 1.4.3 逻辑运算符

| 运算符 | 描述 | 示例 |
|--------|------|------|
| `&&` | 逻辑与 | `a && b` |
| `\|\|` | 逻辑或 | `a \|\| b` |
| `!` | 逻辑非 | `!a` |

```c
#include <stdio.h>

int main() {
    int score = 85;
    int age = 20;
    
    // 关系运算符
    printf("score >= 80: %d\n", score >= 80);  // 1 (真)
    printf("age < 18: %d\n", age < 18);        // 0 (假)
    
    // 逻辑运算符
    printf("score >= 80 && age >= 18: %d\n", score >= 80 && age >= 18);  // 1
    printf("score < 60 || age < 18: %d\n", score < 60 || age < 18);      // 0
    printf("!(score < 60): %d\n", !(score < 60));                       // 1
    
    return 0;
}
```

#### 1.4.4 运算符优先级

运算符按优先级从高到低排列：

1. **后缀**：`()` `[]` `->` `.` `++` `--`
2. **一元**：`!` `~` `++` `--` `+` `-` `*` `&` `sizeof`
3. **乘除模**：`*` `/` `%`
4. **加减**：`+` `-`
5. **移位**：`<<` `>>`
6. **关系**：`<` `<=` `>` `>=`
7. **相等**：`==` `!=`
8. **位与**：`&`
9. **位异或**：`^`
10. **位或**：`|`
11. **逻辑与**：`&&`
12. **逻辑或**：`||`
13. **条件**：`? :`
14. **赋值**：`=` `+=` `-=` 等
15. **逗号**：`,`

### 1.5 分支结构

#### 1.5.1 if语句

```c
#include <stdio.h>

int main() {
    int score;
    
    printf("请输入成绩: ");
    scanf("%d", &score);
    
    // 简单if语句
    if (score >= 60) {
        printf("恭喜！你及格了！\n");
    }
    
    // if-else语句
    if (score >= 90) {
        printf("等级: 优秀\n");
    } else if (score >= 80) {
        printf("等级: 良好\n");
    } else if (score >= 70) {
        printf("等级: 中等\n");
    } else if (score >= 60) {
        printf("等级: 及格\n");
    } else {
        printf("等级: 不及格\n");
    }
    
    return 0;
}
```

#### 1.5.2 switch语句

```c
#include <stdio.h>

int main() {
    int choice;
    
    printf("请选择操作:\n");
    printf("1. 添加\n");
    printf("2. 删除\n");
    printf("3. 修改\n");
    printf("4. 查询\n");
    printf("请输入选择 (1-4): ");
    scanf("%d", &choice);
    
    switch (choice) {
        case 1:
            printf("执行添加操作\n");
            break;
        case 2:
            printf("执行删除操作\n");
            break;
        case 3:
            printf("执行修改操作\n");
            break;
        case 4:
            printf("执行查询操作\n");
            break;
        default:
            printf("无效的选择！\n");
            break;
    }
    
    return 0;
}
```

**switch语句注意事项：**
- 每个case后面要有`break`，否则会继续执行下一个case
- `default`分支是可选的，处理其他情况
- case的值必须是整型常量或字符常量

### 1.6 循环结构

#### 1.6.1 for循环

`for`循环适用于已知循环次数的情况：

```c
for (初始化; 判断条件; 更新) {
    循环体;
}
```

```c
#include <stdio.h>

int main() {
    // 基本for循环
    printf("数字1到10:\n");
    for (int i = 1; i <= 10; i++) {
        printf("%d ", i);
    }
    printf("\n");
    
    // 计算1到100的和
    int sum = 0;
    for (int i = 1; i <= 100; i++) {
        sum += i;
    }
    printf("1到100的和: %d\n", sum);
    
    // 嵌套for循环 - 乘法表
    printf("\n九九乘法表:\n");
    for (int i = 1; i <= 9; i++) {
        for (int j = 1; j <= i; j++) {
            printf("%d×%d=%d\t", j, i, i*j);
        }
        printf("\n");
    }
    
    return 0;
}
```

#### 1.6.2 while循环

`while`循环适用于未知循环次数，但知道循环条件的情况：

```c
#include <stdio.h>

int main() {
    // 基本while循环
    int i = 1;
    printf("使用while循环输出1到5:\n");
    while (i <= 5) {
        printf("%d ", i);
        i++;
    }
    printf("\n");
    
    // 用户输入验证
    int password;
    printf("请输入密码 (正确密码是1234): ");
    scanf("%d", &password);
    
    while (password != 1234) {
        printf("密码错误！请重新输入: ");
        scanf("%d", &password);
    }
    printf("密码正确！欢迎！\n");
    
    return 0;
}
```

#### 1.6.3 do-while循环

`do-while`循环至少执行一次循环体：

```c
#include <stdio.h>

int main() {
    int num;
    
    // do-while循环，至少执行一次
    do {
        printf("请输入一个正数 (0退出): ");
        scanf("%d", &num);
        
        if (num > 0) {
            printf("你输入的数是: %d\n", num);
        } else if (num < 0) {
            printf("请输入正数！\n");
        }
    } while (num != 0);
    
    printf("程序结束！\n");
    
    return 0;
}
```

#### 1.6.4 break和continue语句

- **break**：立即退出循环
- **continue**：跳过本次循环的剩余部分，继续下一次循环

```c
#include <stdio.h>

int main() {
    // break示例
    printf("使用break查找第一个大于5的平方数:\n");
    for (int i = 1; i <= 10; i++) {
        int square = i * i;
        if (square > 5) {
            printf("找到了: %d的平方是%d\n", i, square);
            break;  // 退出循环
        }
    }
    
    // continue示例
    printf("\n只输出1到10中的奇数:\n");
    for (int i = 1; i <= 10; i++) {
        if (i % 2 == 0) {
            continue;  // 跳过偶数
        }
        printf("%d ", i);
    }
    printf("\n");
    
    return 0;
}
```

### 1.7 数组

#### 1.7.1 一维数组

数组是存储同类型数据的容器，通过下标访问元素：

```c
#include <stdio.h>

int main() {
    // 数组声明和初始化
    int numbers[5];                    // 声明包含5个整数的数组
    int scores[5] = {85, 92, 78, 96, 87}; // 声明并初始化
    int values[] = {1, 2, 3, 4, 5};   // 自动确定大小
    
    // 给数组赋值
    numbers[0] = 10;
    numbers[1] = 20;
    numbers[2] = 30;
    numbers[3] = 40;
    numbers[4] = 50;
    
    // 访问和输出数组元素
    printf("numbers数组:\n");
    for (int i = 0; i < 5; i++) {
        printf("numbers[%d] = %d\n", i, numbers[i]);
    }
    
    // 计算数组平均值
    int sum = 0;
    for (int i = 0; i < 5; i++) {
        sum += scores[i];
    }
    float average = (float)sum / 5;
    printf("成绩平均值: %.2f\n", average);
    
    // 查找最大值
    int max = scores[0];
    for (int i = 1; i < 5; i++) {
        if (scores[i] > max) {
            max = scores[i];
        }
    }
    printf("最高分: %d\n", max);
    
    return 0;
}
```

#### 1.7.2 字符数组和字符串

```c
#include <stdio.h>
#include <string.h>

int main() {
    // 字符数组
    char name[20];
    char greeting[] = "Hello";         // 自动添加'\0'
    char message[20] = "World";        // 显式指定大小
    
    // 字符串输入输出
    printf("请输入你的名字: ");
    scanf("%s", name);  // 注意：不需要&符号
    
    printf("你好, %s!\n", name);
    
    // 字符串操作
    char str1[50] = "Hello ";
    char str2[] = "World!";
    
    // 字符串连接
    strcat(str1, str2);
    printf("连接后: %s\n", str1);
    
    // 字符串长度
    printf("字符串长度: %lu\n", strlen(str1));
    
    // 字符串比较
    if (strcmp(str1, "Hello World!") == 0) {
        printf("字符串相等\n");
    }
    
    // 字符串复制
    char copy[50];
    strcpy(copy, str1);
    printf("复制的字符串: %s\n", copy);
    
    return 0;
}
```

#### 1.7.3 二维数组

```c
#include <stdio.h>

int main() {
    // 二维数组声明和初始化
    int matrix[3][4];                 // 3行4列的矩阵
    int grid[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    // 给二维数组赋值
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            matrix[i][j] = i * 4 + j + 1;
        }
    }
    
    // 输出二维数组
    printf("matrix数组:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
            printf("%3d ", matrix[i][j]);
        }
        printf("\n");
    }
    
    printf("\ngrid数组:\n");
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", grid[i][j]);
        }
        printf("\n");
    }
    
    // 计算矩阵行和
    printf("\n各行的和:\n");
    for (int i = 0; i < 3; i++) {
        int rowSum = 0;
        for (int j = 0; j < 3; j++) {
            rowSum += grid[i][j];
        }
        printf("第%d行的和: %d\n", i+1, rowSum);
    }
    
    return 0;
}
```

### 1.8 函数

#### 1.8.1 函数的基本概念

函数是完成特定任务的代码块，是C语言程序的基本构建单元。使用函数可以：
- **代码复用**：避免重复编写相同的代码
- **模块化**：将复杂问题分解为简单的子问题
- **易于维护**：便于调试和修改
- **提高可读性**：让程序结构更清晰

#### 1.8.2 函数的声明和定义

::: card title="函数作用域" 

函数内部声明的变量是局部变量，只在函数内部有效。
:::

```c
#include <stdio.h>

// 函数声明（原型）
int add(int a, int b);
void printLine(void);
float calculateArea(float radius);

// 主函数
int main() {
    int result = add(5, 3);
    printf("5 + 3 = %d\n", result);
    
    printLine();
    
    float area = calculateArea(2.5);
    printf("半径为2.5的圆面积: %.2f\n", area);
    
    return 0;
}

// 函数定义
int add(int a, int b) {
    return a + b;
}

void printLine(void) {
    printf("====================\n");
}

float calculateArea(float radius) {
    const float PI = 3.14159;
    return PI * radius * radius;
}
```

#### 1.8.3 函数参数传递

**按值传递（值传递）**：

```c
#include <stdio.h>

void modifyValue(int x) {
    x = x * 2;
    printf("函数内部: x = %d\n", x);
}

int main() {
    int num = 10;
    printf("调用前: num = %d\n", num);
    
    modifyValue(num);
    
    printf("调用后: num = %d\n", num);  // num的值不会改变
    
    return 0;
}
```

**按引用传递（通过指针）**：

```c
#include <stdio.h>

void modifyValueByPointer(int *x) {
    *x = *x * 2;
    printf("函数内部: *x = %d\n", *x);
}

int main() {
    int num = 10;
    printf("调用前: num = %d\n", num);
    
    modifyValueByPointer(&num);
    
    printf("调用后: num = %d\n", num);  // num的值会改变
    
    return 0;
}
```

#### 1.8.4 递归函数

递归函数是调用自身的函数：

```c
#include <stdio.h>

// 计算阶乘的递归函数
long long factorial(int n) {
    if (n <= 1) {
        return 1;  // 基础情况
    } else {
        return n * factorial(n - 1);  // 递归调用
    }
}

// 斐波那契数列
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int num = 5;
    printf("%d! = %lld\n", num, factorial(num));
    
    printf("斐波那契数列前10项:\n");
    for (int i = 0; i < 10; i++) {
        printf("%d ", fibonacci(i));
    }
    printf("\n");
    
    return 0;
}
```

#### 1.8.5 函数修饰符

##### **inline 关键字**

`inline` 关键字建议编译器将函数代码直接嵌入到调用处，减少函数调用开销：

```c
#include <stdio.h>

// 内联函数声明
inline int max(int a, int b) {
    return (a > b) ? a : b;
}

// 内联函数通常用于简单、频繁调用的函数
inline int square(int x) {
    return x * x;
}

int main() {
    int result1 = max(10, 20);
    int result2 = square(5);
    
    printf("最大值: %d\n", result1);
    printf("平方: %d\n", result2);
    
    return 0;
}
```

**inline的使用建议：**
- 适用于简单、频繁调用的函数
- 编译器可能忽略inline建议
- 在嵌入式开发中，可以提高性能但增加代码大小

##### **static 函数**

`static` 修饰函数时，限制函数的作用域为当前文件：

```c
// file1.c
#include <stdio.h>

// 静态函数，只能在本文件内使用
static int privateFunction(int x) {
    return x * 2;
}

// 普通函数，可以被其他文件调用
int publicFunction(int x) {
    return privateFunction(x) + 1;  // 可以调用静态函数
}

static void internalHelper() {
    printf("这是内部辅助函数\n");
}

int main() {
    int result = publicFunction(5);
    printf("结果: %d\n", result);
    internalHelper();
    
    return 0;
}
```

**static函数的特点：**
- 仅在声明它的源文件内可见
- 避免命名冲突
- 在嵌入式开发中，用于封装模块内部函数

##### **函数指针与修饰符**

函数指针可以指向不同类型的函数：

```c
#include <stdio.h>

// 普通函数
int add(int a, int b) {
    return a + b;
}

// 静态函数
static int multiply(int a, int b) {
    return a * b;
}

// 内联函数
inline int subtract(int a, int b) {
    return a - b;
}

int main() {
    // 函数指针声明
    int (*operation)(int, int);
    
    // 指向不同函数
    operation = add;
    printf("加法: %d\n", operation(5, 3));
    
    operation = multiply;  // 可以指向静态函数
    printf("乘法: %d\n", operation(5, 3));
    
    operation = subtract;  // 可以指向内联函数
    printf("减法: %d\n", operation(5, 3));
    
    return 0;
}
```

### 1.9 指针

#### 1.9.1 指针的基本概念

指针是C语言的核心特性，它存储内存地址，允许直接操作内存：

```c
#include <stdio.h>

int main() {
    int num = 42;
    int *ptr;  // 声明一个指向int的指针
    
    ptr = &num;  // 将num的地址赋给ptr
    
    printf("num的值: %d\n", num);
    printf("num的地址: %p\n", (void*)&num);
    printf("ptr的值(存储的地址): %p\n", (void*)ptr);
    printf("ptr指向的值: %d\n", *ptr);  // 解引用
    
    // 通过指针修改值
    *ptr = 100;
    printf("修改后num的值: %d\n", num);
    
    return 0;
}
```

#### 1.9.2 指针与数组

数组名实际上是指向第一个元素的指针：

```c
#include <stdio.h>

int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *ptr = arr;  // 等价于 int *ptr = &arr[0];
    
    printf("使用数组下标访问:\n");
    for (int i = 0; i < 5; i++) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }
    
    printf("\n使用指针访问:\n");
    for (int i = 0; i < 5; i++) {
        printf("*(ptr + %d) = %d\n", i, *(ptr + i));
    }
    
    printf("\n指针算术:\n");
    ptr = arr;
    for (int i = 0; i < 5; i++) {
        printf("*ptr = %d, 地址: %p\n", *ptr, (void*)ptr);
        ptr++;  // 指针移动到下一个元素
    }
    
    return 0;
}
```

#### 1.9.3 指针与函数

函数可以返回指针，也可以接收指针参数：

```c
#include <stdio.h>

// 函数返回数组中的最大值的地址
int* findMax(int arr[], int size) {
    int *maxPtr = &arr[0];
    for (int i = 1; i < size; i++) {
        if (arr[i] > *maxPtr) {
            maxPtr = &arr[i];
        }
    }
    return maxPtr;
}

// 交换两个变量的值
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int numbers[] = {23, 45, 12, 67, 34};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    
    // 查找最大值
    int *maxPtr = findMax(numbers, size);
    printf("最大值: %d, 地址: %p\n", *maxPtr, (void*)maxPtr);
    
    // 交换变量
    int x = 10, y = 20;
    printf("交换前: x = %d, y = %d\n", x, y);
    swap(&x, &y);
    printf("交换后: x = %d, y = %d\n", x, y);
    
    return 0;
}
```

#### 1.9.4 动态内存分配

在C语言中，可以在运行时动态分配内存：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("请输入数组大小: ");
    scanf("%d", &n);
    
    // 动态分配内存
    int *arr = (int*)malloc(n * sizeof(int));
    
    if (arr == NULL) {
        printf("内存分配失败!\n");
        return 1;
    }
    
    // 输入数据
    printf("请输入%d个整数:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }
    
    // 计算和
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }
    
    printf("数组元素的和: %d\n", sum);
    printf("平均值: %.2f\n", (float)sum / n);
    
    // 释放内存
    free(arr);
    
    return 0;
}
```

### 1.10 结构体

结构体允许将不同类型的数据组合在一起：

```c
#include <stdio.h>
#include <string.h>

// 定义学生结构体
struct Student {
    int id;
    char name[50];
    float score;
};

// 使用typedef简化结构体使用
typedef struct {
    int x;
    int y;
} Point;

// 打印学生信息的函数
void printStudent(struct Student s) {
    printf("学号: %d, 姓名: %s, 成绩: %.2f\n", s.id, s.name, s.score);
}

// 计算两点之间距离
float distance(Point p1, Point p2) {
    int dx = p1.x - p2.x;
    int dy = p1.y - p2.y;
    return sqrt(dx*dx + dy*dy);
}

int main() {
    // 创建和初始化结构体
    struct Student student1 = {1001, "张三", 85.5};
    struct Student student2;
    
    // 给结构体成员赋值
    student2.id = 1002;
    strcpy(student2.name, "李四");
    student2.score = 92.0;
    
    // 使用结构体
    printStudent(student1);
    printStudent(student2);
    
    // 使用typedef定义的结构体
    Point p1 = {0, 0};
    Point p2 = {3, 4};
    
    printf("点1: (%d, %d)\n", p1.x, p1.y);
    printf("点2: (%d, %d)\n", p2.x, p2.y);
    
    return 0;
}
```

### 1.11 文件操作

C语言提供了丰富的文件操作函数：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *file;
    char filename[] = "student_scores.txt";
    int scores[] = {85, 92, 78, 96, 87};
    int readScores[5];
    
    // 写入文件
    file = fopen(filename, "w");
    if (file == NULL) {
        printf("无法创建文件!\n");
        return 1;
    }
    
    fprintf(file, "学生成绩记录\n");
    fprintf(file, "=============\n");
    for (int i = 0; i < 5; i++) {
        fprintf(file, "学生%d: %d\n", i+1, scores[i]);
    }
    fclose(file);
    printf("数据已写入文件 %s\n", filename);
    
    // 读取文件
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("无法打开文件!\n");
        return 1;
    }
    
    printf("\n从文件读取的内容:\n");
    char line[100];
    while (fgets(line, sizeof(line), file) != NULL) {
        printf("%s", line);
    }
    fclose(file);
    
    return 0;
}
```

## 二、C语言项目结构

### 2.1 单文件项目

对于简单的程序，可以将所有代码写在一个`.c`文件中：

```c
// calculator.c
#include <stdio.h>

// 函数声明
double add(double a, double b);
double subtract(double a, double b);
double multiply(double a, double b);
double divide(double a, double b);

int main() {
    double num1, num2;
    char operator;
    
    printf("请输入计算表达式 (如: 5 + 3): ");
    scanf("%lf %c %lf", &num1, &operator, &num2);
    
    double result;
    switch (operator) {
        case '+':
            result = add(num1, num2);
            break;
        case '-':
            result = subtract(num1, num2);
            break;
        case '*':
            result = multiply(num1, num2);
            break;
        case '/':
            if (num2 != 0) {
                result = divide(num1, num2);
            } else {
                printf("错误：除数不能为零!\n");
                return 1;
            }
            break;
        default:
            printf("错误：不支持的运算符!\n");
            return 1;
    }
    
    printf("%.2lf %c %.2lf = %.2lf\n", num1, operator, num2, result);
    return 0;
}

// 函数定义
double add(double a, double b) {
    return a + b;
}

double subtract(double a, double b) {
    return a - b;
}

double multiply(double a, double b) {
    return a * b;
}

double divide(double a, double b) {
    return a / b;
}
```

### 2.2 多文件项目

对于复杂的项目，应该将代码分模块管理：

#### 项目结构示例：
```
led_project/
├── main.c           # 主程序文件
├── led.h            # LED模块头文件
├── led.c            # LED模块实现文件
├── delay.h          # 延时模块头文件
└── delay.c          # 延时模块实现文件
```

#### led.h (头文件)
```c
#ifndef LED_H
#define LED_H

// LED引脚定义
#define LED_PIN 13

// 函数声明
void led_init(void);
void led_on(void);
void led_off(void);
void led_toggle(void);

#endif
```

#### led.c (实现文件)
```c
#include "led.h"
#include <stdio.h>

void led_init(void) {
    printf("LED初始化完成\n");
}

void led_on(void) {
    printf("LED点亮\n");
}

void led_off(void) {
    printf("LED熄灭\n");
}

void led_toggle(void) {
    static int led_state = 0;
    if (led_state) {
        led_off();
        led_state = 0;
    } else {
        led_on();
        led_state = 1;
    }
}
```

#### delay.h
```c
#ifndef DELAY_H
#define DELAY_H

void delay_ms(unsigned int ms);

#endif
```

#### delay.c
```c
#include "delay.h"
#include <stdio.h>

void delay_ms(unsigned int ms) {
    printf("延时 %u 毫秒\n", ms);
    // 实际嵌入式开发中这里会是真正的延时代码
}
```

#### main.c
```c
#include <stdio.h>
#include "led.h"
#include "delay.h"

int main() {
    printf("LED闪烁程序启动\n");
    
    // 初始化LED
    led_init();
    
    // LED闪烁10次
    for (int i = 0; i < 10; i++) {
        led_toggle();
        delay_ms(500);
    }
    
    printf("程序结束\n");
    return 0;
}
```

## 三、C语言编程规范

### 3.1 命名规范

```c
// 常量定义：全大写，下划线分隔
#define MAX_BUFFER_SIZE     256
#define LED_PIN_NUMBER      13

// 变量命名：小写，下划线分隔
int sensor_value;
float temperature_celsius;
bool is_system_ready;

// 函数命名：小写，下划线分隔，动词开头
void gpio_init(void);
int uart_send_data(uint8_t *data, uint16_t length);
bool timer_is_expired(void);

// 结构体：首字母大写，下划线分隔
typedef struct {
    uint16_t id;
    uint32_t timestamp;
    float value;
} Sensor_Data_t;

// 枚举：全大写，前缀标识
typedef enum {
    UART_STATE_IDLE,
    UART_STATE_TRANSMIT,
    UART_STATE_RECEIVE,
    UART_STATE_ERROR
} uart_state_t;
```

### 3.2 代码风格

```c
// 函数定义格式
int calculate_average(int *array, int size) {
    // 参数检查
    if (array == NULL || size <= 0) {
        return -1;  // 错误返回值
    }
    
    int sum = 0;
    
    // 计算总和
    for (int i = 0; i < size; i++) {
        sum += array[i];
    }
    
    return sum / size;
}

// 条件语句格式
if (condition1) {
    // 单个条件
    do_something();
} else if (condition2 && condition3) {
    // 多个条件
    do_something_else();
} else {
    // 默认情况
    do_default_action();
}

// switch语句格式
switch (state) {
    case STATE_INIT:
        initialize_system();
        break;
        
    case STATE_RUN:
        run_main_task();
        break;
        
    case STATE_ERROR:
        handle_error();
        break;
        
    default:
        // 应该处理所有未预期的情况
        report_unknown_state();
        break;
}
```
